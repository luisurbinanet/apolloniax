using System;
using System.Collections.Generic;
using System.Data;
using System.Text;
using OpenDentBusiness;

namespace OpenDentBusiness {
	class General2 {
		///<summary></summary>
		[Obsolete("This method now throws an exception!")]
		public static DataTable GetTable(string command) {
			DataTable retVal;
			if(RemotingClient.OpenDentBusinessIsLocal) {
				retVal=GeneralB.GetTable(command).Tables[0].Copy();
			}
			else {
				DtoGeneralGetTable dto=new DtoGeneralGetTable();
				dto.Command=command;
				retVal=RemotingClient.ProcessQuery(dto).Tables[0].Copy();
			}
			retVal.TableName="";//this is needed for FormQuery dataGrid
			return retVal;
		}

		///<summary>Same as GetTable, but will throw exception if query fails instead of displaying message.  Used in ClassConvertDatabase and any place where we want to be able to suppress the exception message or handle it differently.</summary>
		public static DataTable GetTableEx(string command) {
			DataTable retVal;
			if(RemotingClient.OpenDentBusinessIsLocal) {
				retVal=GeneralB.GetTable(command).Tables[0].Copy();
			}
			else {
				DtoGeneralGetTable dto=new DtoGeneralGetTable();
				dto.Command=command;
				retVal=RemotingClient.ProcessQuery(dto).Tables[0].Copy();
			}
			retVal.TableName="";//this is needed for FormQuery dataGrid
			return retVal;
		}

		///<summary>This is used for queries written by the user.  If using the server component, it uses the user with lower privileges  to prevent injection attack.</summary>
		[Obsolete("This method now throws an exception!")]
		public static DataTable GetTableLow(string command) {
			DataTable retVal;
			if(RemotingClient.OpenDentBusinessIsLocal) {
				retVal=GeneralB.GetTable(command).Tables[0].Copy();
			}
			else {
				DtoGeneralGetTableLow dto=new DtoGeneralGetTableLow();
				dto.Command=command;
				retVal=RemotingClient.ProcessQuery(dto).Tables[0].Copy();
			}
			retVal.TableName="";//this is needed for FormQuery dataGrid
			return retVal;
		}

		///<summary>This is for multiple queries all concatenated together with ;</summary>
		[Obsolete("This method now throws an exception!")]
		public static DataSet GetDataSet(string commands) {
			if(RemotingClient.OpenDentBusinessIsLocal) {
				return GeneralB.GetDataSet(commands);
			}
			else {
				DtoGeneralGetDataSet dto=new DtoGeneralGetDataSet();
				dto.Commands=commands;
				return RemotingClient.ProcessQuery(dto);
			}
		}

		public static DataSet GetDS(string methodName, string parameter1) {
			return GetDS(methodName,new string[] {parameter1});
		}

		public static DataSet GetDS(string methodName,string parameter1,string parameter2) {
			return GetDS(methodName,new string[] { parameter1,parameter2 });
		}

		public static DataSet GetDS(string methodName,string parameter1,string parameter2,string parameter3) {
			return GetDS(methodName,new string[] { parameter1,parameter2,parameter3 });
		}

		///<summary>This is the new way.  If there are more than about 3 parameters, then we'll have to create a different DTO to pass them.  This has not been done yet.  A dataset would be used to pass the parameters up because the information can be better organized, and properly keyed.  But for typical cases with just one or a few parameters, this works great.</summary>
		[Obsolete("This method now throws an exception!")]
		public static DataSet GetDS(string methodName, string[] parameters) {
			if(RemotingClient.OpenDentBusinessIsLocal) {
				return GeneralB.GetDS(methodName,parameters);
			}
			else {
				DtoGetDS dto=new DtoGetDS();
				dto.MethodName=methodName;
				dto.Parameters=parameters;
				return RemotingClient.ProcessGetDS(dto);
			}
		}

		///<summary>Same as GetDataSet, but will throw exception if query fails instead of displaying message.</summary>
		public static DataSet GetDataSetEx(string commands) {
			if(RemotingClient.OpenDentBusinessIsLocal) {
				return GeneralB.GetDataSet(commands);
			}
			else {
				DtoGeneralGetDataSet dto=new DtoGeneralGetDataSet();
				dto.Commands=commands;
				return RemotingClient.ProcessQuery(dto);
			}
		}

		///<summary>This query is run with full privileges.  This is for commands generated by the main program, and the user will not have access for injection attacks.  Result is usually number of rows changed, or can be insert id if requested.</summary>
		[Obsolete("This method now throws an exception!")]
		public static int NonQ(string command, bool getInsertID) {
			if(RemotingClient.OpenDentBusinessIsLocal) {
				return GeneralB.NonQ(command,getInsertID);
			}
			else {
				DtoGeneralNonQ dto=new DtoGeneralNonQ();
				dto.Command=command;
				dto.GetInsertID=getInsertID;
				return RemotingClient.ProcessCommand(dto);
			}
		}

		public static int NonQ(string command) {
			return NonQ(command,false);
		}

		///<summary>We need to get away from this due to poor support from databases.  For now, each command will be sent entirely separately.  This never returns number of rows affected.</summary>
		[Obsolete("This method now throws an exception!")]
		public static int NonQ(string[] commands) {
			for(int i=0;i<commands.Length;i++) {
				if(RemotingClient.OpenDentBusinessIsLocal) {
					GeneralB.NonQ(commands[i],false);
				}
				else {
					DtoGeneralNonQ dto=new DtoGeneralNonQ();
					dto.Command=commands[i];
					dto.GetInsertID=false;
					RemotingClient.ProcessCommand(dto);
				}
			}
			return 0;
		}

		///<summary>Same as NonQ, but will throw exception if query fails instead of displaying message.  Used in ClassConvertDatabase and any place where we want to be able to suppress the exception message or handle it differently.</summary>
		public static int NonQEx(string command,bool getInsertID) {
			if(RemotingClient.OpenDentBusinessIsLocal) {
				return GeneralB.NonQ(command,getInsertID);
			}
			else {
				DtoGeneralNonQ dto=new DtoGeneralNonQ();
				dto.Command=command;
				dto.GetInsertID=getInsertID;
				return RemotingClient.ProcessCommand(dto);
			}
		}

		public static int NonQEx(string command) {
			return NonQEx(command,false);
		}

		///<summary></summary>
		public static int NonQEx(string[] commands) {
			for(int i=0;i<commands.Length;i++) {
				if(RemotingClient.OpenDentBusinessIsLocal) {
					GeneralB.NonQ(commands[i],false);
				}
				else {
					DtoGeneralNonQ dto=new DtoGeneralNonQ();
					dto.Command=commands[i];
					dto.GetInsertID=false;
					RemotingClient.ProcessCommand(dto);
				}
			}
			return 0;
		}

		///<summary>Use this for count(*) queries.  They are always guaranteed to return one and only one value.  Not any faster, just handier.  Can also be used when retrieving prefs manually, since they will also return exactly one value.</summary>
		[Obsolete("This method now throws an exception!")]
		public static string GetCount(string command) {
			if(RemotingClient.OpenDentBusinessIsLocal) {
				return GeneralB.GetTable(command).Tables[0].Rows[0][0].ToString();
			}
			else {
				DtoGeneralGetTable dto=new DtoGeneralGetTable();
				dto.Command=command;
				return RemotingClient.ProcessQuery(dto).Tables[0].Rows[0][0].ToString();
			}
		}

		///<summary>Same as GetCount, but will throw exception if query fails instead of displaying message.</summary>
		public static string GetCountEx(string command) {
			if(RemotingClient.OpenDentBusinessIsLocal) {
				return GeneralB.GetTable(command).Tables[0].Rows[0][0].ToString();
			}
			else {
				DtoGeneralGetTable dto=new DtoGeneralGetTable();
				dto.Command=command;
				return RemotingClient.ProcessQuery(dto).Tables[0].Rows[0][0].ToString();
			}
		}
	}
}
